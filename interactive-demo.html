<!doctype html>

<meta charset="utf-8" />
<title>Dagre Interactive Demo</title>

<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
<script src="https://unpkg.com/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>
<script src="https://unpkg.com/monaco-editor@0.52.2/min/vs/loader.js"></script>

<style>
  svg {
    border: 1px solid #999;
    overflow: hidden;
  }

  .node {
    white-space: nowrap;
  }

  .node rect,
  .node circle,
  .node ellipse {
    stroke: #333;
    fill: #fff;
    stroke-width: 1.5px;
  }

  .cluster rect {
    stroke: #333;
    fill: #000;
    fill-opacity: 0.1;
    stroke-width: 1.5px;
  }

  .edgePath path.path {
    stroke: #333;
    stroke-width: 1.5px;
    fill: none;
  }
</style>

<style>
  h1,
  h2 {
    color: #333;
  }

  textarea {
    width: 800px;
  }

  label {
    display: block;
    margin-top: 1em;
  }

  .error {
    color: red;
  }

  #monacoEditorContainer {
    border: 1px solid #ccc;
    width: 800px;
    height: 200px;
  }
</style>

<body>
  <h1>Dagre Interactive Demo</h1>

  <h2>Input</h2>

  <form>
    <label style="display: none">
      <div>Graphviz Definition (Textarea)</div>
      <textarea id="inputGraph" rows="5" style="display: block">
/* Example */
digraph {
    /* Note: HTML labels do not work in IE, which lacks support for &lt;foreignObject&gt; tags. */
    node [rx=5 ry=5 labelStyle="font: 300 14px 'Helvetica Neue', Helvetica"]
    edge [labelStyle="font: 300 14px 'Helvetica Neue', Helvetica"]
    A [labelType="html"
       label="A <span style='font-size:32px'>Big</span> <span style='color:red;'>HTML</span> Source!"];
    C;
    E [label="Bold Red Sink" style="fill: #f77; font-weight: bold"];
    A -&gt; B -&gt; C;
    B -&gt; D [label="A blue label" labelStyle="fill: #55f; font-weight: bold;"];
    D -&gt; E [label="A thick red edge" style="stroke: #f77; stroke-width: 2px;" arrowheadStyle="fill: #f77"];
    C -&gt; E;
    A -&gt; D [labelType="html" label="A multi-rank <span style='color:blue;'>HTML</span> edge!"];
}
</textarea
      >
    </label>

    <label>
      <div>Graphviz Definition (Monaco)</div>
      <div id="monacoEditorContainer"></div>
    </label>

    <a id="graphLink">Link for this graph</a>
  </form>

  <h2>Graph Visualization</h2>

  <svg height="600" width="800">
    <g />
  </svg>

  <script>
    const TextAreaEditor = {
      element: document.getElementById("inputGraph"),

      initialize(initialValue) {
        this.element.value = initialValue;
      },

      getValue() {
        return this.element.value;
      },

      setValue(text) {
        this.element.value = text;
      },

      showError() {
        this.element.classList.add("error");
        // Optionally, you could add more visual cues here
      },

      clearError() {
        this.element.classList.remove("error");
      },

      // Add an event listener for input changes
      onInputChange(callback) {
        this.element.addEventListener("input", callback);
      },
    };

    const MonacoEditor = {
      editorInstance: null,
      containerElement: null,
      _changeCallback: null,
      _debounceTimer: null,

      initialize(initialValue) {
        this.containerElement = document.getElementById("monacoEditorContainer");

        require.config({
          paths: {
            vs: "https://unpkg.com/monaco-editor@0.52.2/min/vs",
          },
        });
        require(["vs/editor/editor.main"], () => {
          this.editorInstance = monaco.editor.create(this.containerElement, {
            value: initialValue,
            language: "plaintext", // 'dot' language not built-in
            theme: "vs-light",
            automaticLayout: true, // Handles resize
            minimap: { enabled: false },
            scrollBeyondLastLine: false,
            renderLineHighlight: "none",
            matchBrackets: false,
            trimAutoWhitespace: true,
          });
          this._changeCallback?.();

          if (this._changeCallback) {
            this.editorInstance.onDidChangeModelContent(() => {
              if (this._debounceTimer) clearTimeout(this._debounceTimer);
              this._debounceTimer = setTimeout(() => this._changeCallback(), 500);
            });
          }
        });
      },

      getValue() {
        return this.editorInstance ? this.editorInstance.getValue() : "";
      },
      setValue(text) {
        if (this.editorInstance) this.editorInstance.setValue(text);
      },
      showError() {
        if (this.containerElement) this.containerElement.style.borderColor = "red";
      },
      clearError() {
        if (this.containerElement) this.containerElement.style.borderColor = "#ccc";
      },

      onInputChange(callback) {
        this._changeCallback = callback;
        if (this.editorInstance) {
          this.editorInstance.onDidChangeModelContent(() => {
            if (this._debounceTimer) clearTimeout(this._debounceTimer);
            this._debounceTimer = setTimeout(() => this._changeCallback(), 500);
          });
        }
      },
    };

    const GraphVisualizer = {
      svg: d3.select("svg"),
      innerG: d3.select("svg g"),
      renderer: dagreD3.render(),
      currentGraphData: null,

      setupZoom() {
        const zoom = d3.zoom().on("zoom", () => {
          this.innerG.attr("transform", d3.event.transform);
        });
        this.svg.call(zoom);
      },

      parseGraph(dotString) {
        try {
          this.currentGraphData = graphlibDot.read(dotString);
          return { success: true, graph: this.currentGraphData };
        } catch (e) {
          this.currentGraphData = null; // Clear previous graph data on error
          console.error("Graph parsing error:", e); // Log the actual error
          return { success: false, error: e };
        }
      },

      renderGraph() {
        if (!this.currentGraphData) return; // Don't render if no valid graph

        const g = this.currentGraphData;
        // Set margins, if not present
        if (!g.graph().hasOwnProperty("marginx") && !g.graph().hasOwnProperty("marginy")) {
          g.graph().marginx = 20;
          g.graph().marginy = 20;
        }
        g.graph().transition = (selection) => selection.transition().duration(500);

        this.innerG.call(this.renderer, g);
      },
    };

    const Demo = {
      graphLink: d3.select("#graphLink"),
      oldInputGraphValue: null,
      debounceTimer: null,
      debugAlignment: null,
      editor: MonacoEditor,

      initialize() {
        const urlParams = new URLSearchParams(window.location.search);
        const initialGraph = urlParams.get("graph");
        this.debugAlignment = urlParams.get("alignment");

        this.editor.initialize(initialGraph ? decodeURIComponent(initialGraph) : TextAreaEditor.element.value);
        this.editor.onInputChange(() => {
          clearTimeout(this.debounceTimer);
          this.debounceTimer = setTimeout(() => this.tryDraw(), 500);
        });

        GraphVisualizer.setupZoom();

        this.tryDraw();
      },

      graphToURL() {
        const url = new URL(window.location.href);
        url.searchParams.set("graph", encodeURIComponent(this.editor.getValue()));
        if (this.debugAlignment) {
          url.searchParams.set("alignment", this.debugAlignment);
        }
        return url.toString();
      },

      tryDraw() {
        const currentGraphValue = this.editor.getValue();
        if (this.oldInputGraphValue !== currentGraphValue) {
          this.editor.clearError();
          this.oldInputGraphValue = currentGraphValue;

          const parseResult = GraphVisualizer.parseGraph(currentGraphValue);

          this.graphLink.attr("href", this.graphToURL());
          if (parseResult.success) {
            GraphVisualizer.renderGraph();
          } else {
            this.editor.showError();
          }
        }
      },
    };

    document.addEventListener("DOMContentLoaded", () => Demo.initialize());
  </script>
</body>
